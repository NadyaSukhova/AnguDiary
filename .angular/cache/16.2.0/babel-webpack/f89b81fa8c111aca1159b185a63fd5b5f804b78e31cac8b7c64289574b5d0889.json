{"ast":null,"code":"'use strict';\n\nconst CursorType = require('../constants/cursor');\nconst CommandCodes = require('../constants/commands');\nconst Types = require('../constants/types');\nconst Packet = require('../packets/packet');\nconst CharsetToEncoding = require('../constants/charset_encodings.js');\nfunction isJSON(value) {\n  return Array.isArray(value) || value.constructor === Object || typeof value.toJSON === 'function' && !Buffer.isBuffer(value);\n}\n\n/**\n * Converts a value to an object describing type, String/Buffer representation and length\n * @param {*} value\n */\nfunction toParameter(value, encoding, timezone) {\n  let type = Types.VAR_STRING;\n  let length;\n  let writer = function (value) {\n    // eslint-disable-next-line no-invalid-this\n    return Packet.prototype.writeLengthCodedString.call(this, value, encoding);\n  };\n  if (value !== null) {\n    switch (typeof value) {\n      case 'undefined':\n        throw new TypeError('Bind parameters must not contain undefined');\n      case 'number':\n        type = Types.DOUBLE;\n        length = 8;\n        writer = Packet.prototype.writeDouble;\n        break;\n      case 'boolean':\n        value = value | 0;\n        type = Types.TINY;\n        length = 1;\n        writer = Packet.prototype.writeInt8;\n        break;\n      case 'object':\n        if (Object.prototype.toString.call(value) === '[object Date]') {\n          type = Types.DATETIME;\n          length = 12;\n          writer = function (value) {\n            // eslint-disable-next-line no-invalid-this\n            return Packet.prototype.writeDate.call(this, value, timezone);\n          };\n        } else if (isJSON(value)) {\n          value = JSON.stringify(value);\n          type = Types.JSON;\n        } else if (Buffer.isBuffer(value)) {\n          length = Packet.lengthCodedNumberLength(value.length) + value.length;\n          writer = Packet.prototype.writeLengthCodedBuffer;\n        }\n        break;\n      default:\n        value = value.toString();\n    }\n  } else {\n    value = '';\n    type = Types.NULL;\n  }\n  if (!length) {\n    length = Packet.lengthCodedStringLength(value, encoding);\n  }\n  return {\n    value,\n    type,\n    length,\n    writer\n  };\n}\nclass Execute {\n  constructor(id, parameters, charsetNumber, timezone) {\n    this.id = id;\n    this.parameters = parameters;\n    this.encoding = CharsetToEncoding[charsetNumber];\n    this.timezone = timezone;\n  }\n  static fromPacket(packet, encoding) {\n    const stmtId = packet.readInt32();\n    const flags = packet.readInt8();\n    const iterationCount = packet.readInt32();\n    let i = packet.offset;\n    while (i < packet.end - 1) {\n      if ((packet.buffer[i + 1] === Types.VAR_STRING || packet.buffer[i + 1] === Types.NULL || packet.buffer[i + 1] === Types.DOUBLE || packet.buffer[i + 1] === Types.TINY || packet.buffer[i + 1] === Types.DATETIME || packet.buffer[i + 1] === Types.JSON) && packet.buffer[i] === 1 && packet.buffer[i + 2] === 0) {\n        break;\n      } else {\n        packet.readInt8();\n      }\n      i++;\n    }\n    const types = [];\n    for (let i = packet.offset + 1; i < packet.end - 1; i++) {\n      if ((packet.buffer[i] === Types.VAR_STRING || packet.buffer[i] === Types.NULL || packet.buffer[i] === Types.DOUBLE || packet.buffer[i] === Types.TINY || packet.buffer[i] === Types.DATETIME || packet.buffer[i] === Types.JSON) && packet.buffer[i + 1] === 0) {\n        types.push(packet.buffer[i]);\n        packet.skip(2);\n      }\n    }\n    packet.skip(1);\n    const values = [];\n    for (let i = 0; i < types.length; i++) {\n      if (types[i] === Types.VAR_STRING) {\n        values.push(packet.readLengthCodedString(encoding));\n      } else if (types[i] === Types.DOUBLE) {\n        values.push(packet.readDouble());\n      } else if (types[i] === Types.TINY) {\n        values.push(packet.readInt8());\n      } else if (types[i] === Types.DATETIME) {\n        values.push(packet.readDateTime());\n      } else if (types[i] === Types.JSON) {\n        values.push(JSON.parse(packet.readLengthCodedString(encoding)));\n      }\n      if (types[i] === Types.NULL) {\n        values.push(null);\n      }\n    }\n    return {\n      stmtId,\n      flags,\n      iterationCount,\n      values\n    };\n  }\n  toPacket() {\n    // TODO: don't try to calculate packet length in advance, allocate some big buffer in advance (header + 256 bytes?)\n    // and copy + reallocate if not enough\n    // 0 + 4 - length, seqId\n    // 4 + 1 - COM_EXECUTE\n    // 5 + 4 - stmtId\n    // 9 + 1 - flags\n    // 10 + 4 - iteration-count (always 1)\n    let length = 14;\n    let parameters;\n    if (this.parameters && this.parameters.length > 0) {\n      length += Math.floor((this.parameters.length + 7) / 8);\n      length += 1; // new-params-bound-flag\n      length += 2 * this.parameters.length; // type byte for each parameter if new-params-bound-flag is set\n      parameters = this.parameters.map(value => toParameter(value, this.encoding, this.timezone));\n      length += parameters.reduce((accumulator, parameter) => accumulator + parameter.length, 0);\n    }\n    const buffer = Buffer.allocUnsafe(length);\n    const packet = new Packet(0, buffer, 0, length);\n    packet.offset = 4;\n    packet.writeInt8(CommandCodes.STMT_EXECUTE);\n    packet.writeInt32(this.id);\n    packet.writeInt8(CursorType.NO_CURSOR); // flags\n    packet.writeInt32(1); // iteration-count, always 1\n    if (parameters) {\n      let bitmap = 0;\n      let bitValue = 1;\n      parameters.forEach(parameter => {\n        if (parameter.type === Types.NULL) {\n          bitmap += bitValue;\n        }\n        bitValue *= 2;\n        if (bitValue === 256) {\n          packet.writeInt8(bitmap);\n          bitmap = 0;\n          bitValue = 1;\n        }\n      });\n      if (bitValue !== 1) {\n        packet.writeInt8(bitmap);\n      }\n      // TODO: explain meaning of the flag\n      // afaik, if set n*2 bytes with type of parameter are sent before parameters\n      // if not, previous execution types are used (TODO prooflink)\n      packet.writeInt8(1); // new-params-bound-flag\n      // Write parameter types\n      parameters.forEach(parameter => {\n        packet.writeInt8(parameter.type); // field type\n        packet.writeInt8(0); // parameter flag\n      });\n      // Write parameter values\n      parameters.forEach(parameter => {\n        if (parameter.type !== Types.NULL) {\n          parameter.writer.call(packet, parameter.value);\n        }\n      });\n    }\n    return packet;\n  }\n}\nmodule.exports = Execute;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}