{"ast":null,"code":"'use strict';\n\n// based on code from Brian White @mscdex mariasql library - https://github.com/mscdex/node-mariasql/blob/master/lib/Client.js#L272-L332\n// License: https://github.com/mscdex/node-mariasql/blob/master/LICENSE\nconst RE_PARAM = /(?:\\?)|(?::(\\d+|(?:[a-zA-Z][a-zA-Z0-9_]*)))/g,\n  DQUOTE = 34,\n  SQUOTE = 39,\n  BSLASH = 92;\nfunction parse(query) {\n  let ppos = RE_PARAM.exec(query);\n  let curpos = 0;\n  let start = 0;\n  let end;\n  const parts = [];\n  let inQuote = false;\n  let escape = false;\n  let qchr;\n  const tokens = [];\n  let qcnt = 0;\n  let lastTokenEndPos = 0;\n  let i;\n  if (ppos) {\n    do {\n      for (i = curpos, end = ppos.index; i < end; ++i) {\n        let chr = query.charCodeAt(i);\n        if (chr === BSLASH) escape = !escape;else {\n          if (escape) {\n            escape = false;\n            continue;\n          }\n          if (inQuote && chr === qchr) {\n            if (query.charCodeAt(i + 1) === qchr) {\n              // quote escaped via \"\" or ''\n              ++i;\n              continue;\n            }\n            inQuote = false;\n          } else if (chr === DQUOTE || chr === SQUOTE) {\n            inQuote = true;\n            qchr = chr;\n          }\n        }\n      }\n      if (!inQuote) {\n        parts.push(query.substring(start, end));\n        tokens.push(ppos[0].length === 1 ? qcnt++ : ppos[1]);\n        start = end + ppos[0].length;\n        lastTokenEndPos = start;\n      }\n      curpos = end + ppos[0].length;\n    } while (ppos = RE_PARAM.exec(query));\n    if (tokens.length) {\n      if (curpos < query.length) {\n        parts.push(query.substring(lastTokenEndPos));\n      }\n      return [parts, tokens];\n    }\n  }\n  return [query];\n}\n;\nfunction createCompiler(config) {\n  if (!config) config = {};\n  if (!config.placeholder) {\n    config.placeholder = '?';\n  }\n  let ncache = 100;\n  let cache;\n  if (typeof config.cache === 'number') {\n    ncache = config.cache;\n  }\n  if (typeof config.cache === 'object') {\n    cache = config.cache;\n  }\n  if (config.cache !== false && !cache) {\n    cache = new (require('lru-cache'))({\n      max: ncache\n    });\n  }\n  function toArrayParams(tree, params) {\n    const arr = [];\n    if (tree.length == 1) {\n      return [tree[0], []];\n    }\n    if (typeof params == 'undefined') throw new Error('Named query contains placeholders, but parameters object is undefined');\n    const tokens = tree[1];\n    for (let i = 0; i < tokens.length; ++i) {\n      arr.push(params[tokens[i]]);\n    }\n    return [tree[0], arr];\n  }\n  function noTailingSemicolon(s) {\n    if (s.slice(-1) == ':') {\n      return s.slice(0, -1);\n    }\n    return s;\n  }\n  function join(tree) {\n    if (tree.length == 1) {\n      return tree;\n    }\n    let unnamed = noTailingSemicolon(tree[0][0]);\n    for (let i = 1; i < tree[0].length; ++i) {\n      if (tree[0][i - 1].slice(-1) == ':') {\n        unnamed += config.placeholder;\n      }\n      unnamed += config.placeholder;\n      unnamed += noTailingSemicolon(tree[0][i]);\n    }\n    const last = tree[0][tree[0].length - 1];\n    if (tree[0].length == tree[1].length) {\n      if (last.slice(-1) == ':') {\n        unnamed += config.placeholder;\n      }\n      unnamed += config.placeholder;\n    }\n    return [unnamed, tree[1]];\n  }\n  function compile(query, paramsObj) {\n    let tree;\n    if (cache && (tree = cache.get(query))) {\n      return toArrayParams(tree, paramsObj);\n    }\n    tree = join(parse(query));\n    if (cache) {\n      cache.set(query, tree);\n    }\n    return toArrayParams(tree, paramsObj);\n  }\n  compile.parse = parse;\n  return compile;\n}\n\n// named :one :two to postgres-style numbered $1 $2 $3\nfunction toNumbered(q, params) {\n  const tree = parse(q);\n  const paramsArr = [];\n  if (tree.length == 1) {\n    return [tree[0], paramsArr];\n  }\n  const pIndexes = {};\n  let pLastIndex = 0;\n  let qs = '';\n  let varIndex;\n  const varNames = [];\n  for (let i = 0; i < tree[0].length; ++i) {\n    varIndex = pIndexes[tree[1][i]];\n    if (!varIndex) {\n      varIndex = ++pLastIndex;\n      pIndexes[tree[1][i]] = varIndex;\n    }\n    if (tree[1][i]) {\n      varNames[varIndex - 1] = tree[1][i];\n      qs += tree[0][i] + '$' + varIndex;\n    } else {\n      qs += tree[0][i];\n    }\n  }\n  return [qs, varNames.map(n => params[n])];\n}\nmodule.exports = createCompiler;\nmodule.exports.toNumbered = toNumbered;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}