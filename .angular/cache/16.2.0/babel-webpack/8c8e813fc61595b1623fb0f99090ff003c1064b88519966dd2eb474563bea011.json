{"ast":null,"code":"/**\n * @fileoverview Strengthen the ability of file system\n * @author wliao <wliao@Ctrip.com> \n */\nvar fs = require('fs');\nvar util = require('./vendor/util');\nvar path = require('path');\nfunction checkCbAndOpts(options, callback) {\n  if (util.isFunction(options)) {\n    return {\n      options: null,\n      callback: options\n    };\n  } else if (util.isObject(options)) {\n    return {\n      options: options,\n      callback: callback\n    };\n  } else {\n    return {\n      options: null,\n      callback: util.noop\n    };\n  }\n}\nfunction getDirs(filepath) {\n  filepath = filepath.replace(/\\/$/, '').replace(/\\\\$/, '');\n  if (util.path.isAbsolute(filepath)) {\n    return filepath.split(path.sep);\n  } else {\n    return filepath.split('/');\n  }\n}\n/**\n * @description\n * @example\n * `*.js`  only match current dir files\n * '**\\/*.js' match all js files\n * 'path/*.js' match js files in path\n * '!*.js' exclude js files \n */\nfunction filterToReg(filter) {\n  if (!filter) return null;\n  if (util.isString(filter)) {\n    filter = [filter];\n  }\n  var match = [];\n  var negate = [];\n  filter.forEach(function (item) {\n    var isNegate = item.indexOf('!') === 0;\n    item = item.replace(/^!/, '').replace(/\\*(?![\\/*])/, '[^/]*?').replace('**\\/', '([^/]+\\/)*').replace(/([\\/\\.])/g, '\\\\$1');\n    item = '(^' + item + '$)';\n    if (isNegate) {\n      negate.push(item);\n    } else {\n      match.push(item);\n    }\n  });\n  match = match.length ? new RegExp(match.join('|')) : null;\n  negate = negate.length ? new RegExp(negate.join('|')) : null;\n  return function (filepath) {\n    // Normalize \\\\ paths to / paths.\n    filepath = util.path.unixifyPath(filepath);\n    if (negate && negate.test(filepath)) {\n      return false;\n    }\n    if (match && match.test(filepath)) {\n      return true;\n    }\n    return false;\n  };\n}\nutil.extend(exports, fs);\n\n/**\n * @description\n * Assign node origin methods to fs\n */\nexports.fs = fs;\n\n/**\n * @description\n * Create dir, if dir don't exists, it will not throw error.\n * And will mkdir for path, it is asynchronous.\n *\n * @example\n * ```js\n *   fs.mkdir('1/2/3/4/5', 511);\n *   fs.mkdir('path/2/3', function(err) {});\n * ```\n */\nexports.mkdir = function (filepath, mode, callback) {\n  var dirs = getDirs(filepath);\n  var length = dirs.length;\n  if (util.isFunction(mode)) {\n    callback = mode;\n    mode = null;\n  }\n  if (!util.isFunction(callback)) {\n    callback = util.noop;\n  }\n  mode = mode || 511;\n  while (length--) {\n    exists = fs.existsSync(filepath);\n    if (exists) {\n      break;\n    } else {\n      item = dirs[length];\n      last = filepath.lastIndexOf(item);\n      filepath = filepath.slice(0, last);\n    }\n  }\n  dirs = dirs.slice(length + 1);\n  function create(filepath) {\n    if (create.count == dirs.length) {\n      var err;\n      if (!create.count) {\n        err = new Error(\"EEXIST mkdir '\" + filepath + \"'\");\n      }\n      return callback(err);\n    }\n    filepath = path.join(filepath, dirs[create.count]);\n    fs.mkdir(filepath, mode, function (err) {\n      create.count++;\n      create(filepath);\n    });\n  }\n  create.count = 0;\n  create(filepath);\n};\n\n/**\n * @description\n * Same as mkdir, but it is synchronous\n */\nexports.mkdirSync = function (filepath, mode) {\n  var dirs = getDirs(filepath);\n  var length = dirs.length;\n  var item, last, exists;\n  while (length--) {\n    exists = fs.existsSync(filepath);\n    if (exists) {\n      break;\n    } else {\n      item = dirs[length];\n      last = filepath.lastIndexOf(item);\n      filepath = filepath.slice(0, last);\n    }\n  }\n  dirs.slice(length + 1).forEach(function (item) {\n    filepath = path.join(filepath, item);\n    fs.mkdirSync(filepath, mode);\n  });\n};\n\n/**\n * @description \n * Create file, if path don't exists, it will not throw error.\n * And will mkdir for path, it is asynchronous\n * \n * @example\n * ```js\n *   fs.writeFile('path/filename.txt', 'something')\n *   fs.writeFile('path/filename.txt', 'something', {})\n * ```\n */\nexports.writeFile = function (filename, data, options, callback) {\n  var result = checkCbAndOpts(options, callback);\n  var dirname = path.dirname(filename);\n  options = result.options;\n  callback = result.callback;\n\n  // Create dir first\n  exports.mkdir(dirname, function () {\n    fs.writeFile(filename, data, options, callback);\n  });\n};\n\n/**\n * @description\n * Same as writeFile, but it is synchronous\n */\nexports.writeFileSync = function (filename, data, options) {\n  var dirname = path.dirname(filename);\n  exports.mkdirSync(dirname);\n  fs.writeFileSync(filename, data, options);\n};\n\n/**\n * @description\n * Recurse into a directory, executing callback for each file and folder\n * if the filename is undefiend, the callback is for folder, otherwise for file.\n * and it is asynchronous\n * @example\n * file.recurse('path', function(filepath, filename) { });\n * file.recurse('path', ['*.js', 'path/**\\/*.html'], function(filepath, filename) { });\n */\nexports.recurse = function (dirpath, filter, callback) {\n  if (util.isFunction(filter)) {\n    callback = filter;\n    filter = null;\n  }\n  var filterCb = filterToReg(filter);\n  var rootpath = dirpath;\n  function recurse(dirpath) {\n    fs.readdir(dirpath, function (err, files) {\n      if (err) return callback(err);\n      files.forEach(function (filename) {\n        var filepath = path.join(dirpath, filename);\n        fs.stat(filepath, function (err, stats) {\n          if (stats.isDirectory()) {\n            recurse(filepath);\n            callback(filepath);\n          } else {\n            if (filterCb) {\n              var relative = path.relative(rootpath, filepath);\n              if (filterCb(relative)) {\n                callback(filepath, filename);\n              }\n            } else {\n              callback(filepath, filename);\n            }\n          }\n        });\n      });\n    });\n  }\n  recurse(dirpath);\n};\n\n/**\n * @description\n * Same as recurse, but it is synchronous\n * @example\n * file.recurseSync('path', function(filepath, filename) {});\n * file.recurseSync('path', ['*.js', 'path/**\\/*.html'], function(filepath, filename) {});\n */\nexports.recurseSync = function (dirpath, filter, callback) {\n  if (util.isFunction(filter)) {\n    callback = filter;\n    filter = null;\n  }\n  var filterCb = filterToReg(filter);\n  var rootpath = dirpath;\n  function recurse(dirpath) {\n    // permission bug\n    try {\n      fs.readdirSync(dirpath).forEach(function (filename) {\n        var filepath = path.join(dirpath, filename);\n        var stats = fs.statSync(filepath);\n        if (stats.isDirectory()) {\n          recurse(filepath);\n          callback(filepath);\n        } else {\n          if (filterCb) {\n            var relative = path.relative(rootpath, filepath);\n            if (filterCb(relative)) {\n              callback(filepath, filename);\n            }\n          } else {\n            callback(filepath, filename);\n          }\n        }\n      });\n    } catch (e) {\n      fs.chmodSync(dirpath, 511);\n      recurse(dirpath);\n    }\n  }\n  recurse(dirpath);\n};\n\n/**\n * @description\n * Remove folder and files in folder, but it's synchronous\n * @example\n * file.rmdirSync('path');\n * file.rmdirSync('path/file.txt');\n */\nexports.rmdirSync = function (dirpath) {\n  var stats = fs.statSync(dirpath);\n  if (stats.isFile()) {\n    fs.unlinkSync(dirpath);\n  } else {\n    exports.recurseSync(dirpath, function (filepath, filename) {\n      // it is file, otherwise it's folder\n      if (filename) {\n        fs.unlinkSync(filepath);\n      } else {\n        fs.rmdirSync(filepath);\n      }\n    });\n    fs.rmdirSync(dirpath);\n  }\n};\n\n/**\n * @description\n * Copy dirpath to destpath, pass process callback for each file hanlder\n * if you want to change the dest filepath, process callback return { contents: '', filepath: ''}\n * otherwise only change contents\n * @example\n * file.copySync('path', 'dest');\n * file.copySync('src', 'dest/src');\n * file.copySync('path', 'dest', { process: function(contents, filepath) {} });\n */\nexports.copySync = function (dirpath, destpath, options) {\n  var defaults = {\n    encoding: 'utf8',\n    filter: null,\n    process: function (contents) {\n      return contents;\n    }\n  };\n  options = util.extend(defaults, options || {});\n  var folders = [];\n  var files = [];\n  exports.recurseSync(dirpath, options.filter, function (filepath, filename) {\n    if (filename) {\n      files.push(filepath);\n    } else {\n      folders.push(filepath);\n    }\n  });\n  folders = folders.filter(function (item, index) {\n    var length = folders.length;\n    while (length--) {\n      var newItem = folders[length];\n      var isSubdir = newItem.indexOf(item) === 0;\n      var notSamelevel = newItem.split(path.sep).length != item.split(path.sep).length;\n      if (isSubdir && notSamelevel) {\n        return false;\n      }\n    }\n    return true;\n  });\n\n  // if dirpath don't exists folder\n  if (!folders.length) {\n    fs.mkdirSync(destpath);\n  }\n\n  // first create dir\n  folders.forEach(function (folder) {\n    var relative = path.relative(dirpath, folder);\n    exports.mkdirSync(path.join(destpath, relative));\n  });\n\n  // write file\n  files.forEach(function (filepath) {\n    var contents = fs.readFileSync(filepath, {\n      encoding: options.encoding\n    });\n    var result = options.process(contents, filepath);\n\n    // change file formate\n    if (util.isString(result)) {\n      result = {\n        contents: result,\n        filepath: filepath\n      };\n    }\n    var relative = path.relative(dirpath, result.filepath);\n    var newPath = path.join(destpath, relative);\n    fs.writeFileSync(newPath, result.contents, {\n      encoding: options.encoding\n    });\n  });\n};","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}