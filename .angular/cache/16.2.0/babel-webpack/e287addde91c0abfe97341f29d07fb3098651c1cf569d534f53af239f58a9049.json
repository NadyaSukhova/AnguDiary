{"ast":null,"code":"'use strict';\n\n// https://mysqlserverteam.com/mysql-8-0-4-new-default-authentication-plugin-caching_sha2_password/\nconst PLUGIN_NAME = 'caching_sha2_password';\nconst crypto = require('crypto');\nconst {\n  xor,\n  xorRotating\n} = require('../auth_41');\nconst REQUEST_SERVER_KEY_PACKET = Buffer.from([2]);\nconst FAST_AUTH_SUCCESS_PACKET = Buffer.from([3]);\nconst PERFORM_FULL_AUTHENTICATION_PACKET = Buffer.from([4]);\nconst STATE_INITIAL = 0;\nconst STATE_TOKEN_SENT = 1;\nconst STATE_WAIT_SERVER_KEY = 2;\nconst STATE_FINAL = -1;\nfunction sha256(msg) {\n  const hash = crypto.createHash('sha256');\n  hash.update(msg);\n  return hash.digest();\n}\nfunction calculateToken(password, scramble) {\n  if (!password) {\n    return Buffer.alloc(0);\n  }\n  const stage1 = sha256(Buffer.from(password));\n  const stage2 = sha256(stage1);\n  const stage3 = sha256(Buffer.concat([stage2, scramble]));\n  return xor(stage1, stage3);\n}\nfunction encrypt(password, scramble, key) {\n  const stage1 = xorRotating(Buffer.from(`${password}\\0`, 'utf8'), scramble);\n  return crypto.publicEncrypt(key, stage1);\n}\nmodule.exports = (pluginOptions = {}) => ({\n  connection\n}) => {\n  let state = 0;\n  let scramble = null;\n  const password = connection.config.password;\n  const authWithKey = serverKey => {\n    const _password = encrypt(password, scramble, serverKey);\n    state = STATE_FINAL;\n    return _password;\n  };\n  return data => {\n    switch (state) {\n      case STATE_INITIAL:\n        scramble = data.slice(0, 20);\n        state = STATE_TOKEN_SENT;\n        return calculateToken(password, scramble);\n      case STATE_TOKEN_SENT:\n        if (FAST_AUTH_SUCCESS_PACKET.equals(data)) {\n          state = STATE_FINAL;\n          return null;\n        }\n        if (PERFORM_FULL_AUTHENTICATION_PACKET.equals(data)) {\n          const isSecureConnection = typeof pluginOptions.overrideIsSecure === 'undefined' ? connection.config.ssl || connection.config.socketPath : pluginOptions.overrideIsSecure;\n          if (isSecureConnection) {\n            state = STATE_FINAL;\n            return Buffer.from(`${password}\\0`, 'utf8');\n          }\n\n          // if client provides key we can save one extra roundrip on first connection\n          if (pluginOptions.serverPublicKey) {\n            return authWithKey(pluginOptions.serverPublicKey);\n          }\n          state = STATE_WAIT_SERVER_KEY;\n          return REQUEST_SERVER_KEY_PACKET;\n        }\n        throw new Error(`Invalid AuthMoreData packet received by ${PLUGIN_NAME} plugin in STATE_TOKEN_SENT state.`);\n      case STATE_WAIT_SERVER_KEY:\n        if (pluginOptions.onServerPublicKey) {\n          pluginOptions.onServerPublicKey(data);\n        }\n        return authWithKey(data);\n      case STATE_FINAL:\n        throw new Error(`Unexpected data in AuthMoreData packet received by ${PLUGIN_NAME} plugin in STATE_FINAL state.`);\n    }\n    throw new Error(`Unexpected data in AuthMoreData packet received by ${PLUGIN_NAME} plugin in state ${state}`);\n  };\n};","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}